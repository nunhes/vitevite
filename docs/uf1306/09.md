---
title: Animaci√≥ns baseadas no Scroll (Scroll-triggered Animations)
description: As animaci√≥ns baseadas no scroll se activan cando o usuario despraza a p√°xina.
lastUpdated: true
---

# {{ $frontmatter.title }}

## **üåê Introduci√≥n**
As animaci√≥ns baseadas no scroll permiten crear efectos que se **activan cando o usuario despraza a p√°xina**, engadindo:
- **Profundidade** ao dese√±o
- **Narrativa visual**
- **Experiencias interactivas**

---

## **üõ†Ô∏è 3 M√©todos principais**

### **1. CSS puro (Intersection Observer)**
```css
.elemento {
  opacity: 0;
  transform: translateY(20px);
  transition: all 0.6s ease;
}

.elemento.visible {
  opacity: 1;
  transform: translateY(0);
}
```

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add('visible');
    }
  });
}, { threshold: 0.1 });

document.querySelectorAll('.animar').forEach(el => observer.observe(el));
```

### **2. Scroll-driven Animations (CSS moderno)**

```css
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(50px); }
  to { opacity: 1; transform: translateY(0); }
}

.elemento {
  animation: fadeIn linear;
  animation-timeline: view();
  animation-range: entry 20% cover 30%;
}
```

### **3. Bibliotecas JavaScript**
- **GSAP + ScrollTrigger** (m√°is potente)
- **AOS (Animate On Scroll)** (m√°is sinxelo)

```javascript
// Exemplo con GSAP
gsap.registerPlugin(ScrollTrigger);

gsap.from(".elemento", {
  scrollTrigger: {
    trigger: ".elemento",
    start: "top 80%",
  },
  x: -100,
  opacity: 0,
  duration: 1
});
```

---

## **üé® Exemplos com√∫ns**

### **1. Efecto parallax**

```css
.parallax {
  background-attachment: fixed;
  background-position: center;
  background-repeat: no-repeat;
  background-size: cover;
  height: 100vh;
}
```

### **2. Reveal animations**

```css
@keyframes slideIn {
  from { transform: translateX(-100%); }
  to { transform: translateX(0); }
}

.reveal {
  view-timeline: --reveal block;
  animation: slideIn ease-in;
  animation-timeline: --reveal;
  animation-range: entry 25% cover 50%;
}
```

### **3. Progress bar**

```css
.progress-bar {
  position: fixed;
  top: 0;
  left: 0;
  height: 5px;
  background: linear-gradient(to right, #ff8a00, #e52e71);
  transform-origin: left;
  transform: scaleX(0);
  animation: progressBar linear;
  animation-timeline: scroll(root);
}

@keyframes progressBar {
  from { transform: scaleX(0); }
  to { transform: scaleX(1); }
}
```

---

## **‚ö° Boas pr√°cticas**

1. **Optimizaci√≥n de performance**:
   - Usar `will-change: transform` para elementos complexos
   - Evitar animar propiedades custosas como `margin` ou `height`

2. **Accesibilidade**:
   - Respectar `prefers-reduced-motion`
   ```css
   @media (prefers-reduced-motion) {
     .animacion { animation: none !important; }
   }
   ```

3. **Dese√±o responsivo**:
   - Axustar os puntos de activaci√≥n para m√≥biles
   ```javascript
   { threshold: window.innerWidth < 768 ? 0.2 : 0.1 }
   ```

---

## **üîß Ferramentas recomendadas**

| Ferramenta                       | Uso                        | Dificultade |
| -------------------------------- | -------------------------- | ----------- |
| **Intersection Observer API**    | Soluci√≥n nativa            | Media       |
| **CSS Scroll-driven Animations** | Novidade CSS (Chrome 115+) | Baixa       |
| **GSAP ScrollTrigger**           | Animaci√≥ns avanzadas       | Alta        |
| **AOS Library**                  | Implementaci√≥n r√°pida      | Moi baixa   |

---

## **üì± Exemplo responsivo**

```html
<!DOCTYPE html>
<html>
<head>
  <style>
    .section {
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 2rem;
      opacity: 0;
      transform: translateY(50px);
      transition: all 0.8s ease;
    }

    .section.visible {
      opacity: 1;
      transform: translateY(0);
    }

    @media (prefers-reduced-motion) {
      .section {
        transition: none !important;
      }
    }
  </style>
</head>
<body>
  <div class="section">Contido 1</div>
  <div class="section">Contido 2</div>
  <div class="section">Contido 3</div>

  <script>
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    }, { 
      threshold: window.innerWidth < 768 ? 0.1 : 0.3 
    });

    document.querySelectorAll('.section').forEach(el => observer.observe(el));
  </script>
</body>
</html>
```

---

## **üöÄ Consellos avanzados**

1. **Scroll-linked storytelling**:
   - Crear narrativas visuais que se revelan ao desprazar

2. **Efectos 3D**:
   ```css
   .card {
     transform-style: preserve-3d;
     transition: transform 1s;
   }
   
   .card:hover {
     transform: rotateY(180deg);
   }
   ```

3. **Debugging**:
   - Chrome DevTools > Performance panel para analizar rendemento

---

## **üìö Recursos adicionais**

- [Scroll-driven Animations Guide](https://developer.chrome.com/docs/css-ui/scroll-driven-animations)
- [GSAP ScrollTrigger Docs](https://greensock.com/scrolltrigger/)
- [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)

