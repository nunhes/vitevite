---
title: Programaci贸n orientada a obxectos en JavaScript i
description: A programaci贸n orientada a obxectos 茅 un estilo de programaci贸n baseado en clases e obxectos. 
lastUpdated: true
---

# {{ $frontmatter.title }}

A programaci贸n orientada a obxectos 茅 un estilo de programaci贸n baseado en clases e obxectos. Estes agrupan datos (propiedades) e m茅todos (acci贸ns) dentro dunha caixa.

A POO foi desenvolvida para facer o c贸digo m谩is flexible e doado de manter.

JavaScript 茅 unha linguaxe procedimental baseada en prototipos, o que significa que admite tanto programaci贸n funcional como orientada a obxectos.

# Que son as clases e os obxectos en JavaScript?

## Que 茅 unha clase?

Podes pensar nunha clase como o plano dunha casa. Unha clase non 茅 un obxecto do mundo real, pero podemos crear obxectos a partir dunha clase.  como un modelo para un obxecto.

Podemos crear clases usando a `class`palabra clave, que 茅 unha palabra clave reservada en JavaScript. As clases poden ter as s煤as propias propiedades e m茅todos. Estudaremos como crear unha clase en detalle en breve. Esta 茅 s贸 unha visi贸n xeral dun nivel b谩sico dunha clase.

Vexamos un exemplo. A continuaci贸n m贸strase un plano para unha casa (como unha clase).

![Imaxe](./assets/blueprint.jpg)

*Plano de vivenda (clase)*

## Que 茅 un obxecto?

Un obxecto 茅 unha instancia dunha clase. Agora, coa axuda da clase casa podemos constru铆r unha casa. Podemos constru铆r varias casas coa axuda da mesma clase casa.

### Exemplo de clases e obxectos en acci贸n

Vexamos un exemplo sinxelo para entender como funcionan as clases e os obxectos.

O exemplo de embaixo non ten nada que ver coa sintaxe de JavaScript. S贸 serve para explicar as clases e os obxectos. Estudaremos a sintaxe da POO en JavaScript nun intre.

Considere unha clase Estudante. A clase Estudante pode ter propiedades como nome, idade, est谩ndar, etc., e funci贸ns como estudar, xogar e facer os deberes.

```javascript
class Student{
 // Data (Properties)
 Name
 Age
 Standard

 // Methods (Action)
 study(){
 // Study
 }

 Play(){
 // Play
 }

 doHomeWork(){
 // Do Home Work
 }

}
```

Coa axuda da clase anterior, podemos ter varios estudantes ou instancias.

**Aqu铆 tes informaci贸n para** `**Student - 01**`**:**

```javascript
// Student 1
{
Name = "John"
Age = 15
Standard = 9

study(){
 // Study
 }

 Play(){
 // Play
 }

 doHomeWork(){
 // Do Home Work
 }

}
```

**Aqu铆 tes informaci贸n para** `**Student - 02**`**:**

```javascript
// Student 2
{
Name = "Gorge"
Age = 18
Standard = 12

study(){
 // Study
 }

 Play(){
 // Play
 }

 doHomeWork(){
 // Do Home Work
 }

}
```

# Como dese帽amos realmente unha clase?

Non hai unha resposta perfecta a esta pregunta. Pero podemos obter axuda dalg煤ns principios de POO ao dese帽ar as nosas clases.

Hai 4 principios b谩sicos na POO, e son:

- Abstracci贸n
- Encapsulaci贸n
- Herdanza
- Polimorfismo

Afondaremos nestes conceptos de JavaScript a continuaci贸n. Pero primeiro, imos obter unha visi贸n xeral destes conceptos para comprendelos mellor.

## Que significa abstracci贸n en POO?

A abstracci贸n significa ocultar certos detalles que non lle importan ao usuario e mostrar s贸 as caracter铆sticas ou funci贸ns esenciais.

Por exemplo, tomemos un tel茅fono m贸bil. Non mostramos detalles como `verifyTemperature()`, `verifyVolt()`, `frontCamOn()`, `frontCamOff()`etc. En vez diso, proporcionamos funci贸ns esenciais que son importantes para o usuario, como camera(), volumeBtn() e outras.

## Que significa encapsulaci贸n en POO?

A encapsulaci贸n significa manter as propiedades e os m茅todos privados dentro dunha clase, de xeito que non sexan accesibles desde f贸ra desa clase.

Isto evitar谩 que o c贸digo que est谩 f贸ra da clase manipule accidentalmente m茅todos e propiedades internas.

## Que significa herdanza en POO?

A herdanza pon todas as propiedades e m茅todos 谩 disposici贸n dunha clase filla. Isto perm铆tenos reutilizar a l贸xica com煤n e modelar relaci贸ns do mundo real. Falaremos da herdanza nunha secci贸n posterior deste artigo con exemplos pr谩cticos.

## Que significa polimorfismo en POO?

O polimorfismo significa ter moitas e diferentes formas. Podemos sobrescribir un m茅todo herdado dunha clase nai.

```javascript
// Not actual JavaScript syntax
class User{
email 
password

login(providedPassword){
    // Login User
}

checkMessage(){
// Check any new message
}
}
// Not actual JavaScript syntax
class Admin inherit user{
email // Inherited Property
password // Inherited Property
permissions // Own Property

// Inherited Method
login(providedPassword){
    // Different Login User
}

// Inherited Method
checkMessage(){
// Check any new message
}

// Own Method
checkStats(){
// Check Stats
}
}
```

O m茅todo de inicio de sesi贸n en Admin 茅 diferente da clase herdada `user`.

# Programaci贸n orientada a obxectos en JavaScript

Xa falamos dos conceptos b谩sicos da POO. Mais a POO en JavaScript 茅 un pouco diferente. Temos un obxecto vinculado a un prototipo. Os prototipos conte帽en todos os m茅todos e estes m茅todos son accesibles para todos os obxectos vinculados a este prototipo. Isto ch谩mase **herdanza prototipal** (ou **delegaci贸n prototipal** ).

## Que 茅 a herdanza protot铆pica en JavaScript?

 probable que xa empregases a herdanza prototipal sen sabelo; por exemplo, se empregaches m茅todos en matrices como `push()`, `pop()`, `map()`, etc. (que est谩n dispo帽ibles en todas as matrices).

Se imos 谩 [documentaci贸n oficial,](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) veremos `Array.prototype.map()` porque `Array.prototype` 茅 un prototipo de todos os obxectos de matriz que creamos en JavaScript. Este 茅 un exemplo de herdanza protot铆pica que imos aprender a implementar.

Do mesmo xeito que con `Array.prototype`, crearemos os nosos propios prototipos e isto axudarache a comprender JavaScript de dentro a f贸ra.

![Imaxe](./assets/ss.png)

*Prototipo dunha matriz*

## Como implementar a herdanza prototipal en JavaScript

Hai tres xeitos principais de implementar a herdanza prototipal en JavaScript:

### Usando funci贸ns de construtor

Podemos crear obxectos a partir dunha funci贸n. Coa axuda dunha funci贸n construtora, implem茅ntanse obxectos integrados como matrices, conxuntos e outros.

En JavaScript, un construtor ch谩mase cando se crea un obxecto usando a palabra clave `new`. O prop贸sito dun construtor 茅 crear un novo obxecto e establecer os seus valores para calquera propiedade do obxecto existente.

### Usando as clases ES6

As clases son unha alternativa 谩 sintaxe da funci贸n do construtor para implementar a herdanza protot铆pica. Tam茅n chamamos clases `syntactic sugar` - azucre sint谩ctico-.

Entre bastidores, as clases funcionan exactamente igual que as funci贸ns de construtor. Antes de ES6, JavaScript non ti帽a conceptos de clases. Para simular unha clase, adoita empregarse o [construtor ou o patr贸n prototipo](https://www.javascripttutorial.net/javascript-constructor-prototype/) .

### Usando Object.create()

Esta 茅 a maneira m谩is sinxela de vincular un obxecto a un obxecto prototipo.  un m茅todo que se emprega para crear un novo obxecto co obxecto prototipo e as propiedades especificadas.

O m茅todo `object.create()` devolve un novo obxecto co prototipo de obxecto e as propiedades especificadas.

Vex谩molos agora con m谩is detalle:

## Como implementar a herdanza protot铆pica con funci贸ns de construtor en JS

Empregaremos unha funci贸n para crear unha herdanza protot铆pica. Comezaremos implementando unha expresi贸n de funci贸n de usuario. Lembra que o nome dunha funci贸n de construtor debe comezar sempre con mai煤scula (convenci贸n est谩ndar).

```javascript
function User(name){
    this.name = name;

    // never create function inside constructor function
    this.printName = function(){
        console.log(this.name);
    }

    console.log(this);
}


let kedar = new User("kedar")
```

**Sa铆da**

![Imaxe](./assets/ss2-2.png)

*Prototipo usando unha funci贸n construtora*

Creamos unha funci贸n construtora no exemplo anterior. Pero cal 茅 a palabra clave `new`? Coa axuda da palabra clave `new` podemos crear unha instancia dese construtor.

Cando creamos unha instancia do obxecto construtor, cr茅ase un obxecto baleiro (`{}`). Este obxecto baleiro (`{}`) v铆nculase ent贸n ao prototipo.

Nunca deberiamos crear unha funci贸n dentro dunha funci贸n construtora. Porque cada vez que se crea unha instancia, cr茅ase unha nova funci贸n con ela que creamos dentro da funci贸n construtora. Isto crear谩 problemas importantes para o rendemento.

A soluci贸n a este problema son os prototipos. Podemos definir unha funci贸n directamente sobre o prototipo dun obxecto. As铆, o obxecto creado usando esa funci贸n construtora ter谩 acceso a esa funci贸n.

**Exemplo:**

```javascript
function User(name){
    this.name = name;

    console.log(this);
}

User.prototype.printName = function(){
    console.log(this.name)
}


let kedar = new User("kedar")
```

![Imaxe](./assets/ss3-2.png)

*Prototipo usando unha funci贸n construtora*

Na sa铆da anterior, podes ver o m茅todo `printName()` no prototipo da funci贸n construtora de usuario. Esta 茅 a forma preferida de crear unha funci贸n nunha funci贸n construtora para optimizar o rendemento.

Ent贸n, agora todos os obxectos creados por esta funci贸n de construtor ter谩n acceso 谩 funci贸n printName().

Podemos acceder a estas funci贸ns con objectName.functionName() deste xeito:

```javascript
function User(name){
    this.name = name;

    console.log(this);
}

User.prototype.printName = function(){
    console.log(this.name)
}

let kedar = new User("kedar")
kedar.printName()
```

Podemos acceder ao prototipo da funci贸n construtora coa seguinte sintaxe:

```javascript
console.log(User.__proto__)
```

O prototipo do obxecto 茅 o mesmo que o prototipo da funci贸n construtora. Mira isto:

```javascript
console.log(kedar.__proto__ === User.prototype) 
// True

console.log(User.prototype.isPrototypeOf(kedar))
// True
```

O prototipo de Usuario 茅 o prototipo empregado polo seu obxecto e non pertence a Usuario.

```javascript
console.log(User.prototype.isPrototypeOf(User))
// False
```

Tam茅n podemos vincular unha variable ao prototipo:

```javascript
User.prototype.species = "Homo Sapiens"
```

Agora esta variable pertence ao prototipo e non ao obxecto. Podemos comprobalo usando `hasOwnProperty()`.

### Herdanza protot铆pica de obxectos incorporados

Temos moitos m茅todos dispo帽ibles para usar en matrices. Como funciona isto?

A resposta 茅 a herdanza protot铆pica. Cando creamos unha nova matriz, cada vez que a creamos herda de `Array.prototype`. As铆 茅 como temos acceso a todos eses m茅todos diferentes.

```javascript
const arr = [1,2,3,4,5]
console.log(arr)
```

![Imaxe](./assets/ss5-2.png)

*Prototipo dunha matriz*

Tam茅n podemos anexar o noso propio m茅todo a `Array.prototype` para que cada vez que creemos unha nova matriz te帽amos acceso a ese m茅todo.

```javascript
const arr = [1,2,4,4,5,5]

Array.prototype.unique = function(){
    return [...new Set(this)]
}

console.log(arr.unique());
```

![Imaxe](./assets/ss6-2.png)

*Prototipo dun array cun m茅todo `unique()` personalizado engadido ao prototipo.*

## Como implementar a herdanza protot铆pica con clases ES6 en JavaScript

Podemos implementar a POO usando clases, pero entre bastidores usa herdanza protot铆pica. Este m茅todo foi introducido para que tivese sentido para a xente que v茅n doutras linguaxes como C++ e Java.

Implementaremos as clases de usuario do exemplo anterior:

```javascript
// Class Expression
class User = class{

}

// Class Declaration
class User{

}
```

No exemplo anterior, podemos ver que hai 2 xeitos de implementar unha clase en JavaScript. Podes escoller calquera deles segundo as t煤as preferencias.

Dentro da clase, o primeiro que temos que facer 茅 engadir un m茅todo construtor. O construtor tam茅n pode aceptar argumentos.

```javascript
class User{
    constructor(name){
        this.name = name
    }

    printName(){
        console.log(this.name);
    }
}

const kedar = new User("kedar")
```

![Imaxe](./assets/ss7-1.png)

*Prototipo usando a clase ES6*

Lembra que sempre que creamos un obxecto dunha clase, primeiro inv贸case un construtor. Se non hai ning煤n construtor, inv贸case o construtor predeterminado, que non fai nada.

### 3 cousas para lembrar sobre as clases

- As clases non se elevan (se non sabes o que 茅 elevar, [le esta gu铆a](https://www.freecodecamp.org/news/javascript-execution-context-and-hoisting/) )
- As clases son cidad谩ns de primeira clase (se unha linguaxe de programaci贸n ten a capacidade de pasar unha funci贸n como argumento, 茅 dicir, tratar as funci贸ns como valores e devolver funci贸ns, dise que a linguaxe ten funci贸ns de primeira clase e esas funci贸ns ch谩manse cidad谩ns de primeira clase)
- As clases exec煤tanse en modo estrito. (Se non sabes o que 茅 o modo estrito, [le esta gu铆a](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) )

### Que son os setters e os getters?

Estes son m茅todos sinxelos de clases que obte帽en e definen un valor. Pero desde f贸ra parecen m茅todos sinxelos. Vexamos o exemplo seguinte.

```javascript
class User{
    constructor(name){
        this._name = name
    }

    get getName(){
        console.log(this._name)
    }

    set setName(newName){
        this._name = newName
    }
}

const kedar = new User("kedar")
kedar.setName = "John"
kedar.getName
```

No exemplo anterior, podes ver como o getter `getName`rexistra un nome. Os setters 煤sanse para definir o valor dunha propiedade existente. Ao definir un nome usando o setter, temos que usar (_) antes do nome da propiedade como convenci贸n.

### Como usar m茅todos est谩ticos

Os m茅todos est谩ticos est谩n vinculados a unha clase e non 谩s instancias da clase ou ao obxecto da clase. Podemos acceder a m茅todos est谩ticos s贸 a trav茅s das clases e non a trav茅s do obxecto desa clase.

```javascript
class User{
    constructor(name){
        this._name = name
    }

    static anonymous(){
        console.log("anonymous");
    }
}

const kedar = new User("kedar")
kedar.anonymous() // error
User.anonymous() // "anonymous"
```

Podemos crear m茅todos est谩ticos directamente dentro das clases usando a palabra clave static antes do nome do m茅todo. No exemplo anterior, observa que s贸 podemos chamar o m茅todo static nunha clase e non nun obxecto de clase.

Hai outra forma de implementar un m茅todo est谩tico:

```c
class User{
    constructor(name){
        this._name = name
    }
}

User.anonymous = function(){
    console.log("anonymous");
}

const kedar = new User("kedar")
kedar.anonymous() // error
User.anonymous() // "anonymous"
```

## Como implementar a herdanza protot铆pica con Object.create() en JavaScript

[O `Object.create()`m茅todo est谩tico crea un novo obxecto, usando un obxecto existente como prototipo do obxecto recentemente creado.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

```javascript
const User = {
    init(name){
        this.name = name
    },

    printName(){
        console.log(this.name);
    }
}

let kedar = Object.create(User)
kedar.init("kedar")
kedar.printName()
```

O obxecto recentemente creado herdar谩 todas as propiedades do obxecto prototipo. Podes especificar un segundo par谩metro para engadir novas propiedades ao obxecto que o prototipo carec铆a:

```javascript
const newObject = Object.create(prototype, newProperties)
const User = {

    printName(){
        console.log(this.name);
    }
}

let properties = {
    name: {
        value:"John"
    }

}

let John = Object.create(User,properties)
John.printName()
```

## Como funciona a herdanza en JavaScript

A herdanza perm铆teche definir unha clase/obxecto que toma toda a funcionalidade dunha clase/obxecto pai e che permite engadir m谩is. Mediante a herdanza de clases, unha clase/obxecto pode herdar todos os m茅todos e propiedades doutra clase.  unha caracter铆stica 煤til que permite a reutilizaci贸n do c贸digo.

Agora botaremos unha ollada 谩 herdanza na funci贸n construtora, nas clases ES6 e en `Object.create()`.

### Funci贸n do construtor

Entendamos a herdanza de funci贸ns de construtor cun exemplo. Se non sabes como funciona a herdanza a alto nivel, consulta a secci贸n onde tratamos "Como dese帽amos realmente unha clase".

**Exemplo:**

```javascript
const User = function(name, password){

    this.name = name
    this.password = password
}

User.prototype.printName = function(){
    console.log(this.name);
}

const Admin = function(name, password){
    this.name = name
    this.password = password
}

Admin.prototype.Stats = function(){
    console.log("Stats");
}

const kedar = new Admin("kedar", 12345)
kedar.Stats()
```

No c贸digo anterior, temos 2 funci贸ns de construtor, e te帽en algunhas semellanzas. A铆nda as铆, escrib铆molo d煤as veces, o que viola o principio DRY (Don't Repeat Yourself - Non te repitas). Para evitar repetir o mesmo c贸digo, usamos herdanza.

```javascript
const User = function(name, password){

    this.name = name
    this.password = password
}

User.prototype.printName = function(){
    console.log(this.name);
}

const Admin = function(name, password, course){
    User.call(this, name, password)
    this.course = course
}

Admin.prototype = Object.create(User.prototype)

Admin.prototype.Stats = function(){
    console.log("Stats");
}

const kedar = new Admin("kedar", 12345, "JavaScript")
kedar.printName()
```

No c贸digo anterior, primeiro na funci贸n Admin (fillo) asociamos `this` a User (pai) e cham谩mola con par谩metros. Unha vez feito isto, puidemos acceder aos campos de nome e contrasinal. Pero non puidemos acceder aos m茅todos da funci贸n pai porque necesitamos conectar o prototipo de User e Admin.

Para iso, xusto despois da funci贸n filla, apuntamos o prototipo de administrador ao prototipo de usuario, o que nos deu acceso aos m茅todos da funci贸n nai (usuario).

Aseg煤rate de apuntar o prototipo fillo (Admin) 谩 funci贸n pai (Usuario) inmediatamente despois da funci贸n filla (Admin). Porque devolve un obxecto baleiro e elimina todos os m茅todos da funci贸n filla (Admin). Polo tanto, crea sempre m茅todos da funci贸n filla (Admin) despois de apuntar o prototipo fillo (Admin) ao prototipo pai (Usuario).

Agora vexamos como queda a nosa cadea prototipo:

![Imaxe](./assets/ss8-1.png)

*Herdanza de prototipos usando funci贸ns de construtor*

Na parte inferior hai un prototipo de Obxecto. Despois diso podemos ver un prototipo de Usuario e na parte superior vemos un prototipo de Administrador.

### ES6

 moi sinxelo implementar a herdanza usando a sintaxe de ES6. Pero lembra que ES6 usa funci贸ns de construtor para implementar a herdanza entre bastidores.

```javascript
class User{
    constructor(name, password){
        this.name = name
        this.password  =password
    }

    printName(){
        console.log(this.name);
    }
}

class Admin extends User{
    constructor(name, password, course){
        super(name, password)
        this.course = course
    }

    Stats(){
        console.log("Stats");
    }
}

const kedar = new Admin("kedar", 123456, "JavaScript")
kedar.printName()
```

Ent贸n temos 2 clases, Usuario e Administrador. Cando queremos herdar, simplemente engadimos `extends`a clase da que queremos herdar diante da clase filla, de xeito similar 谩 sintaxe que se mostra no c贸digo anterior.

Cando rematamos con iso, no construtor da clase filla, chamamos ao `super()`m茅todo para pasar un argumento 谩 clase nai que sexa obrigatorio. As铆 茅 como podemos implementar a herdanza en JavaScript usando a sintaxe ES6.

Tam茅n podemos implementar `override`o m茅todo pai implementando un m茅todo co mesmo nome na clase filla.

```javascript
class User{
    constructor(name, password){
        this.name = name
        this.password  =password
    }

    printName(){
        console.log(this.name);
    }
}

class Admin extends User{
    constructor(name, password, course){
        super(name, password)
        this.course = course
    }

    Stats(){
        console.log("Stats");
    }

    printName(){
        console.log("Child class " + this.name)
    }
}

const kedar = new Admin("kedar", 123456, "JavaScript")
kedar.printName()
```

### Obxecto.crear()

Implementar a herdanza en Object.create() 茅 sinxelo. Consulta o c贸digo seguinte:

```javascript
const User = {
    printName(){
        console.log(this.name);
    },

    init(name, password){
        this.name = name
        this.password = password
    }
}

const Admin = Object.create(User)
Admin.init = function(name, password, course){
    User.init.call(this, name, password)
    this.course = course
}

Admin.stats = function(){
    console.log("Stats");
}

const kedar = Object.create(Admin)
kedar.init("kedar", 123456)
kedar.printName()
kedar.stats()
```

![Imaxe](./assets/ss9-1.png)

*Herdanza de prototipos usando Object.create()*

Primeiro, creamos unha funci贸n Usuario. Despois creamos un Admin que apuntaba a Usuario coa axuda de `Object.create()`. Coa axuda do m茅todo `Admin.init()`, chamamos ao m茅todo `init()` de Usuario e pasamos valores 谩 funci贸n nai.

## Como funciona a encapsulaci贸n en JavaScript

Arriba, vimos o que significa encapsulaci贸n a un nivel moi amplo. Agora veremos un exemplo para explicalo con m谩is detalle.

A encapsulaci贸n p贸dese definir como *"o empaquetamento de datos e funci贸ns nun compo帽ente".* Isto tam茅n se co帽ece como agrupaci贸n ou empaquetado e simplemente significa reunir datos e os m茅todos que operan sobre os datos. Pode ser unha funci贸n, unha clase ou un obxecto.

A encapsulaci贸n permite " *controlar o acceso a ese compo帽ente* ". Cando temos os datos e os m茅todos relacionados nunha soa unidade, podemos controlar como se accede a eles f贸ra da unidade. Este proceso ch谩mase encapsulaci贸n.

### Propiedades protexidas

```javascript
class User{
    constructor(name, password){
        this._name = name
        this._password = password
    }
}

const kedar = new User("kedar", 123456)
console.log(kedar._password);
```

Un membro protexido 茅 accesible dentro da clase e de calquera obxecto que herde dela. Un valor protexido comp谩rtese en todas as capas da cadea de prototipos.

Usamos (_) en `this._name`, que 茅 unha propiedade protexida. A铆nda podemos acceder a esta propiedade f贸ra da clase. Esta 茅 s贸 unha convenci贸n que usan os programadores.

Se sabemos que existe un (_) no nome dunha propiedade, non se sup贸n que debamos manipular esa propiedade desde f贸ra da clase.

```javascript
class User{
    constructor(name, password){
        this._name = name
        this._password = password
    }

    get getName(){
        console.log(this._name)
    }
}

const kedar = new User("kedar", 123456)
kedar.getName
```

### Propiedades privadas

```javascript
class User{
    constructor(name, password){
        this.#name = name
        this._password = password
    }

    get getName(){
        console.log(this._name)
    }
}

const kedar = new User("kedar", 123456)
console.log(kedar.#name);
```

Para implementar unha propiedade verdadeiramente privada en JavaScript temos que usar (#) antes do nome da propiedade ou do m茅todo. Estas propiedades e m茅todos privados non ser谩n accesibles desde f贸ra da clase, o que os far谩 verdadeiramente privados.

Isto axudar谩 a restrinxir o acceso 谩s propiedades desde f贸ra da clase. Se queremos acceder a propiedades desde f贸ra, temos que usar o m茅todo make que s贸 imprimir谩 as propiedades sen dar acceso para cambiar o valor desa propiedade.

```javascript
class User{
    #name

    constructor(name, password){
        this.#name = name
        this._password = password
    }

    #printName(){
        console.log(this.#name);
    }

    PrintFromPrivateMethod(){
        this.#printName()
    }
}

const kedar = new User("kedar", 123456)
kedar.PrintFromPrivateMethod()
```

----

DAW2026
